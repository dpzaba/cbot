#!/usr/bin/env bash
set -o errexit

$current_flow=$CURRENT_FLOW
if [ "$current_flow" != "Product Deploys" ] ; then
  echo "I won't run deploy from the '$current_flow' flow"
  echo "Please call me from 'Product Deploys'"
  exit 1
fi

if [ "$#" -ne 3 ]; then
  echo "Please provide <app> <environment> <branch>"
  exit 1
fi

# assign variables from args
app=$(./helpers/normalize-app-name $1)
appDir=$(cd ../deployables/${app}/; pwd)
appEnv=$2
branch=$3

logFile="/var/log/cbot/${app}_${appEnv}.log"

# Redirect STDOUT and STDERR to the logfile, and save STDOUT to fd 3
exec 3>&1
exec 2>&1 1>$logFile
# print error (if given) then exit with error status
error ()
{
  # Re-establish stdout
  exec >&3-
  if [ "$1" != "" ]; then
    printf "$1"
  fi;
  exit 1
}
# print function which uses aliased STDOUT. Doesn't append \n
print ()
{
  # Re-establish stdout
  if [ "$1" != "" ]; then
    printf "$1" 1>&3
  fi;
}

# save all output to logfile
echo "################## $app $appEnv $branch"
date
echo ""

# assert there's an environment
if [ "$appEnv" == "" ]; then
  error "Please provide an environment"
fi;

# assert environment is not production
if [ "$appEnv" == "production-us" ]; then
  error "Whoooa! Cannot deploy to $appEnv... yet"
fi;

# cd into project
cd $appDir

# Load RVM into a shell session *as a function*
if [[ -s "$HOME/.rvm/scripts/rvm" ]] ; then
  set +o errexit
  source "$HOME/.rvm/scripts/rvm"
  set -o errexit
else
  error "ERROR: An RVM installation was not found"
fi

# assert that git is clean
dirty="$(git status --porcelain)"
if [ -n "$dirty" ]; then
  error "Dirty git directory $(pwd): $dirty"
fi;

# assert that the branch exists
if ! git ls-remote --heads --exit-code origin $branch > /dev/null; then
  error "Branch $branch not found"
fi;

# required so that cbot sends previous message now and not at EOF
print "Starting deploy of $app to $appEnv on branch $branch\n\n"

# fetch any new branches
git fetch --all --quiet
# switch to branch
git checkout $branch --quiet
# update to state of remote branch
git reset --hard origin/$branch --quiet

# ensure we're not behind master
commitsBehind="$(git log --oneline ..origin/master | wc -l | tr -d ' ')"
if [ "$commitsBehind" != "0" ]; then
 print ":heavy_exclamation_mark: $branch is $commitsBehind commits behind master, please merge in master. Continuing with deploy...\n\n"
fi;

# install any dependencies
bundle check || bundle install

## deploy

# do not exit if deploy command fails
set +o errexit
# run cap, saving output to logfile
# return exit code of first command
# http://stackoverflow.com/questions/1221833/bash-pipe-output-and-capture-exit-status
startDeploy=$(date +%s)
# For some reason, bundle didn't play nice with the stdout redirect
# Run the cap command in a subshell to avoid it writting to STDOUT
(
  exec 2>&1 1>>$logFile
  bundle exec cap $appEnv deploy 2>&1
)
deployStatus=$?
endDeploy=$(date +%s)

if [ $deployStatus -ne 0 ]; then
  error ":dizzy_face: Error deploying, see $logFile"
fi;

deployTime=$((endDeploy-startDeploy))
print "Deployed '${app}' to ${appEnv} on branch ${branch} in ${deployTime}s"
